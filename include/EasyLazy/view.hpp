#pragma once

#include "core.hpp"

/// View tag
struct view_tag : expr_tag {};

/// View usefull empty structures
struct all {};
struct newaxis {};

// What a mess...
// The goal was to calculate the shape of a view without a loop! Hum...
namespace {
    /** Output dimension associated to a view-index
     *
     * All and newaxis generates one output dimension, an expression generates as many dimensions as its own dimension,
     * and a scalar generates no dimension in the resulting view.
     */
    template <typename I>
    constexpr std::size_t view_out_index_dim_v = type_traits::is_expr_v<I> ? type_traits::dim_v<I> : (std::is_same_v<std::decay_t<I>, all> || std::is_same_v<std::decay_t<I>, newaxis> ? 1 : 0);

    /** Partial output dimension of a view
     *
     * i.e. how many dimension of the resulting view is generated by the N-first view-indexes
     */
    template <typename Indexes, std::size_t... IndexPos>
    constexpr std::size_t view_out_cumul_dim_impl(std::index_sequence<IndexPos...>)
    {
        return (view_out_index_dim_v<std::tuple_element_t<IndexPos, Indexes>> + ... + 0);
    }

    template <typename Indexes, std::size_t N>
    constexpr std::size_t view_out_cumul_dim_v = view_out_cumul_dim_impl<Indexes>(std::make_index_sequence<N>{});

    /// Output dimension of a view
    template <typename Indexes>
    constexpr std::size_t view_out_dim_v = view_out_cumul_dim_v<Indexes, std::tuple_size_v<Indexes>>;

    /// Input dimension associated to a view-index (every view index uses one input dimension, except newaxis that uses none)
    template <typename I>
    constexpr std::size_t view_in_index_dim_v = std::is_same_v<std::decay_t<I>, newaxis> ? 0 : 1;

    /** Partial input dimension of a view
     *
     * i.e. how many dimension of the input expression is needed by the N-first view-indices.
     */
    template <typename Indexes, std::size_t... IndexPos>
    constexpr std::size_t view_in_cumul_dim_impl(std::index_sequence<IndexPos...>)
    {
        return (view_in_index_dim_v<std::tuple_element_t<IndexPos, Indexes>> + ... + 0);
    }

    template <typename Indexes, std::size_t N>
    constexpr std::size_t view_in_cumul_dim_v = view_in_cumul_dim_impl<Indexes>(std::make_index_sequence<N>{});

    /// Input dimension of a view
    template <typename Indexes>
    constexpr std::size_t view_in_dim_v = view_in_cumul_dim_v<Indexes, std::tuple_size_v<Indexes>>;

    /** Given a dimension from the resulting view, returns the position of the corresponding view-index.
     */
    template <typename Indexes, std::size_t OutDim, std::size_t... IndexPos>
    constexpr std::size_t view_index_pos_from_out_dim_impl(std::index_sequence<IndexPos...>)
    {
        static_assert(OutDim < view_out_dim_v<Indexes>);
        return ((view_out_cumul_dim_v<Indexes, IndexPos> <= OutDim ? 1 : 0) + ... + 0) - 1;
    }

    template <typename Indexes, std::size_t OutDim>
    constexpr std::size_t view_index_pos_from_out_dim_v = view_index_pos_from_out_dim_impl<Indexes, OutDim>(std::make_index_sequence<std::tuple_size_v<Indexes>>{});

    /** Shape associated to a view-index
     *
     * It may depend on the input expression shape...
     */
    template <std::size_t IndexPos, typename ExprShape, typename Indexes>
    auto view_index_shape(visitor::shape const& shape_visitor, ExprShape const& expr_shape, Indexes & indexes)
    {
        using ViewIndex = std::decay_t<std::tuple_element_t<IndexPos, Indexes>>;

        if constexpr (type_traits::is_expr_v<ViewIndex>)
            return std::get<IndexPos>(indexes)(shape_visitor);
        else if constexpr (std::is_same_v<ViewIndex, newaxis>)
            return std::array<std::size_t, 1>{1};
        else if constexpr (std::is_same_v<ViewIndex, all>)
        {
            constexpr std::size_t shape_pos = view_in_cumul_dim_v<Indexes, IndexPos>;
            return std::array<std::size_t, 1>{expr_shape[shape_pos]};
        }
        else
            return std::array<std::size_t, 0>{};
    }

    /// Returns the size of the view along the given dimension
    template <typename Indexes, std::size_t OutDim, typename Shapes>
    std::size_t view_size_at_dim(Shapes const& shapes)
    {
        constexpr std::size_t shape_pos = view_index_pos_from_out_dim_v<Indexes, OutDim>;
        constexpr std::size_t shape_dim = OutDim - view_out_cumul_dim_v<Indexes, shape_pos>;
        return std::get<shape_pos>(shapes)[shape_dim];
    }

    /** Returns the shape of a view
     *
     * Generates the view size along each output dimensions.
     */
    template <typename Indexes, typename Shapes, std::size_t... OutDim>
    auto view_shape_dispatch_out_dim(Shapes const& shapes, std::index_sequence<OutDim...>)
    {
        return std::array{ view_size_at_dim<Indexes, OutDim>(shapes) ... };
    }

    /** Returns the shape of a view
     *
     * Generates the shapes associated to each index.
     * Dispatch along output dimensions so that to generate the view shape.
     */
    template <typename ExprShape, typename Indexes, std::size_t... IndexPos>
    auto view_shape_dispatch_index(visitor::shape const& shape_visitor, ExprShape const& expr_shape, Indexes & index, std::index_sequence<IndexPos...>)
    {
        return view_shape_dispatch_out_dim<Indexes>(
            std::tuple{ view_index_shape<IndexPos>(shape_visitor, expr_shape, index) ... },
            std::make_index_sequence<view_out_dim_v<Indexes>>{}
        );
    }

    /** Returns the shape of a view
     *
     * Dispatch along view indexes so that to generate the shapes associated to each index
     */
    template <typename Expr, typename Indexes>
    auto view_shape_impl(visitor::shape const& shape_visitor, Expr&& expr, Indexes & index)
    {
        return view_shape_dispatch_index(
            shape_visitor,
            std::forward<Expr>(expr)(shape_visitor),
            index,
            std::make_index_sequence<std::tuple_size_v<Indexes>>{}
        );
    }

} // anonymous namespace

/// View expression
template <typename Expr, typename... I>
auto view(Expr && expr, I &&... idx)
{
    return [op = hold_args(std::forward<Expr>(expr)),
            index = hold_args(std::forward<I>(idx)...)]
        (auto && visitor) mutable -> decltype(auto) {
            return std::forward<decltype(visitor)>(visitor)(view_tag{}, std::get<0>(op), index);
        };
}

// Extending core visitors
namespace visitor
{
    template <typename Expr, typename Indexes>
    auto visit(visitor::shape const& shape_visitor, view_tag, Expr && expr, Indexes & indexes)
    {
        return view_shape_impl(
            shape_visitor,
            std::forward<Expr>(expr),
            indexes
        );
    }

} // namespace visitor
